from __future__ import annotations
from dataclasses import dataclass
from typing import Dict, List, Optional, Tuple
import os, time, math
from datetime import datetime
from zoneinfo import ZoneInfo
from sbwatch.notify import post_discord

ET = ZoneInfo("America/New_York")

# --- Tunables (safe defaults) ---
DISPLACEMENT_BODY_MULT   = float(os.getenv("SB_BODY_MULT", "1.6"))   # body > X * 10-bar median body
FVG_LOOKBACK_BARS        = int(os.getenv("SB_FVG_LOOKBACK", "10"))   # use last N bars for body median
MAX_BARS_TO_TAG_FVG      = int(os.getenv("SB_FVG_MAX_WAIT", "6"))    # time to get the FVG retest
ENFORCE_WINDOW           = os.getenv("SB_ENFORCE_WINDOW", "0") == "1" # set to 1 to enforce 10-11 ET
WINDOW_START_HHMM        = os.getenv("SB_WINDOW_START", "10:00")      # if enforced
WINDOW_END_HHMM          = os.getenv("SB_WINDOW_END",   "11:00")

# Liquidity levels weâ€™ll consider
LEVEL_KEYS = [
    "pdh","pdl","asia_high","asia_low","london_high","london_low"
]

@dataclass
class Bar:
    ts_ms: int
    o: float; h: float; l: float; c: float

@dataclass
class SwingState:
    last_high: float = math.nan
    last_low: float  = math.nan

@dataclass
class PendingSB:
    side: str                          # 'long' or 'short'
    disp_bar_i: int                    # index at which displacement occurred
    fvg_top: float; fvg_bot: float     # gap bounds (top > bot)
    sl: float; target_hint: float      # suggested SL and nearest opposite liquidity
    created_ms: int

class SBEngine:
    def __init__(self, levels: Dict[str, float]):
        self.levels = {k: float(v) for k,v in levels.items() if k in LEVEL_KEYS and v is not None}
        self.bars: List[Bar] = []
        self.body_hist: List[float] = []
        self.swings = SwingState()
        self.pending: Optional[PendingSB] = None

    # ---------- helpers ----------
    def _et_in_window(self, ts_ms: int) -> bool:
        if not ENFORCE_WINDOW:
            return True
        t = datetime.fromtimestamp(ts_ms/1000, tz=ET)
        s_h,s_m = map(int, WINDOW_START_HHMM.split(":"))
        e_h,e_m = map(int, WINDOW_END_HHMM.split(":"))
        start = t.replace(hour=s_h, minute=s_m, second=0, microsecond=0)
        end   = t.replace(hour=e_h, minute=e_m, second=0, microsecond=0)
        return start <= t <= end

    def _median_body(self) -> float:
        xs = self.body_hist[-FVG_LOOKBACK_BARS:] or [0.25]
        xs = sorted(xs)
        n = len(xs)
        return xs[n//2] if n % 2 else 0.5*(xs[n//2-1]+xs[n//2])

    def _update_swings(self, i: int):
        # very light swings: previous 3 bars
        if i < 2: return
        b1, b2, b3 = self.bars[i-2], self.bars[i-1], self.bars[i]
        # swing high at b2 if b2.h > b1.h and b2.h > b3.h
        if b2.h > b1.h and b2.h > b3.h: self.swings.last_high = b2.h
        # swing low at b2 if b2.l < b1.l and b2.l < b3.l
        if b2.l < b1.l and b2.l < b3.l: self.swings.last_low = b2.l

    def _nearest_opposite_liquidity(self, side: str, ref: float) -> float:
        keys = ["london_high","asia_high","pdh"] if side=="long" else ["london_low","asia_low","pdl"]
        cands = [self.levels[k] for k in keys if k in self.levels]
        if not cands: return ref
        # pick nearest beyond current ref in the trade direction
        if side=="long":
            bigger = [x for x in cands if x >= ref]
            return min(bigger) if bigger else max(cands)
        else:
            smaller = [x for x in cands if x <= ref]
            return max(smaller) if smaller else min(cands)

    # ---------- SB logic ----------
    def _swept_key_level(self, i: int) -> Optional[str]:
        """Return which key level was swept on bar i (low under a low-level for longs, or high over a high-level for shorts)."""
        b = self.bars[i]
        for name in LEVEL_KEYS:
            v = self.levels.get(name)
            if v is None: continue
            if name.endswith("low") or name=="pdl":
                if b.l < v and b.c > b.o:  # run below + close up
                    return f"long@{name}"
            if name.endswith("high") or name=="pdh":
                if b.h > v and b.c < b.o:  # run above + close down
                    return f"short@{name}"
        return None

    def _is_displacement(self, i: int, side: str) -> bool:
        """Body greater than median of lookback and breaks minor swing in direction."""
        if i == 0: return False
        b = self.bars[i]
        body = abs(b.c - b.o)
        med  = max(self._median_body(), 1e-6)
        takes_swing = (b.h > self.swings.last_high) if side=="long" else (b.l < self.swings.last_low)
        directional = (b.c > b.o) if side=="long" else (b.c < b.o)
        return directional and takes_swing and (body > DISPLACEMENT_BODY_MULT * med)

    def _compute_fvg(self, i: int, side: str) -> Optional[Tuple[float,float]]:
        """3-candle FVG around displacement bar i (body candle)."""
        if i < 1: return None
        a = self.bars[i-1]; b = self.bars[i]
        # use classic 2-candle gap (simple and fast for live). For bullish: a.h < b.l -> gap [a.h, b.l]
        if side=="long" and a.h < b.l:
            return (b.l, a.h) if b.l > a.h else None
        if side=="short" and a.l > b.h:
            return (a.l, b.h) if a.l > b.h else None
        return None

    def _consider_entry_touch(self, i: int):
        """If we have a pending SB, check if current bar trades into the gap in the right direction."""
        if not self.pending: return
        p = self.pending; b = self.bars[i]
        # invalidate if taking too long
        if i - p.disp_bar_i > MAX_BARS_TO_TAG_FVG:
            self.pending = None
            return
        if p.side=="long":
            # price trades down into the gap and closes up
            if b.l <= p.fvg_top and b.c >= p.fvg_top:
                self._emit_entry("long", i, p)
                self.pending = None
        else:
            if b.h >= p.fvg_bot and b.c <= p.fvg_bot:
                self._emit_entry("short", i, p)
                self.pending = None

    def _emit_entry(self, side: str, i: int, p: PendingSB):
        b = self.bars[i]
        ts = datetime.fromtimestamp(b.ts_ms/1000, tz=ET).isoformat()
        print(f"[SB-ENTRY] {ts} side={side} entry={b.c:.2f} fvg=({p.fvg_top:.2f},{p.fvg_bot:.2f}) "
              f"sl={p.sl:.2f} target~{p.target_hint:.2f}", flush=True)

    # public API used by run_live.py
    def on_bar(self, ts_ms: int, o: float, h: float, l: float, c: float):
        # window gate (optional)
        if not self._et_in_window(ts_ms):
            return

        self.bars.append(Bar(ts_ms, o, h, l, c))
        self.body_hist.append(abs(c - o))
        i = len(self.bars) - 1

        # if we have a pending FVG, check touch/re-entry first
        self._consider_entry_touch(i)

        # 1) look for a fresh sweep on this bar
        sweep = self._swept_key_level(i)
        if not sweep:
            return
        side = "long" if sweep.startswith("long@") else "short"

        # 2) look for displacement candle (this bar qualifies *or* wait for next bar)
        if not self._is_displacement(i, side):
            return

        # 3) compute FVG from displacement bar
        fvg = self._compute_fvg(i, side)
        if not fvg:
            return

        # keep swings fresh (moved here)
        self._update_swings(i)

        # keep swings fresh (moved here)
        self._update_swings(i)

        fvg_top, fvg_bot = (max(fvg), min(fvg))
        # SL: below/above recent swing
        sl = (self.swings.last_low if side=="long" else self.swings.last_high)
        if math.isnan(sl):  # fallback
            sl = l if side=="long" else h

        target_hint = self._nearest_opposite_liquidity(side, c)

        # stage a pending entry waiting for return to FVG
        self.pending = PendingSB(
            side=side, disp_bar_i=i, fvg_top=fvg_top, fvg_bot=fvg_bot,
            sl=sl, target_hint=target_hint, created_ms=self.bars[i].ts_ms
        )
