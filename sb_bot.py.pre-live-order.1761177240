from zoneinfo import ZoneInfo
from pathlib import Path
import json
from sbwatch.live_adapter import iter_live_bars, Bar
#!/usr/bin/env python3
import os, sys, json, time, datetime as dt
from dataclasses import dataclass
from typing import List, Dict, Tuple, Optional

from dotenv import load_dotenv
import pytz, requests

try:
    from databento import Historical, Live
except Exception:
    print("Databento SDK missing. pip install -r requirements.txt", file=sys.stderr)
    sys.exit(1)

# --- Config & constants ---
BASE_DIR = os.path.dirname(__file__)
ET = pytz.timezone("America/Indiana/Indianapolis")
UTC = pytz.utc
load_dotenv(os.path.join(BASE_DIR, ".env"))

DB_API_KEY = os.getenv("DB_API_KEY", "")
DISCORD_WEBHOOK = os.getenv("DISCORD_WEBHOOK", "")
DATASET = os.getenv("DATASET", "GLBX.MDP3")
SCHEMA  = os.getenv("SCHEMA",  "ohlcv-1m")
SYMBOL  = os.getenv("SYMBOL",  "NQZ5")
MIN_DISPLACEMENT_TICKS = int(os.getenv("MIN_DISPLACEMENT_TICKS", "8"))
MAX_LOOKBACK_MIN       = int(os.getenv("MAX_LOOKBACK_MIN", "200"))

INCLUDE_ASIA_LONDON = os.getenv("INCLUDE_ASIA_LONDON", "0") == "1"
ASIA_START  = os.getenv("ASIA_START",  "20:00")
ASIA_END    = os.getenv("ASIA_END",    "00:00")
LONDON_START= os.getenv("LONDON_START","02:00")
LONDON_END  = os.getenv("LONDON_END",  "05:00")

USE_PDH_PDL_AS_SWEEP = os.getenv("USE_PDH_PDL_AS_SWEEP", "1") == "1"
USE_ASIA_AS_SWEEP    = os.getenv("USE_ASIA_AS_SWEEP",    "1") == "1"
USE_LONDON_AS_SWEEP  = os.getenv("USE_LONDON_AS_SWEEP",  "1") == "1"

if not DB_API_KEY or not DISCORD_WEBHOOK:
    print("Missing DB_API_KEY or DISCORD_WEBHOOK in .env", file=sys.stderr)
    sys.exit(1)

TICK_SIZE = 0.25          # NQ tick
PRICE_DIVISOR = 1e9       # << correct divisor for GLBX.MDP3 OHLCV

@dataclass
class Candle:
    ts: dt.datetime
    o: float; h: float; l: float; c: float; v: int

def now_et() -> dt.datetime: return dt.datetime.now(tz=ET)
def to_utc_str(t: dt.datetime) -> str: return t.astimezone(UTC).strftime("%Y-%m-%dT%H:%M:%SZ")

def dsend(msg: str):
    try: requests.post(DISCORD_WEBHOOK, json={"content": msg}, timeout=5)
    except Exception as e: print(f"Discord error: {e}", file=sys.stderr)

# --- helpers to read Databento rows/messages robustly ---
def _get_attr(obj, name, default=None):
    if hasattr(obj, name): return getattr(obj, name)
    try: return obj[name]
    except Exception: return default

def _parse_ts_ns(obj) -> Optional[int]:
    return _get_attr(obj, "ts", _get_attr(obj, "ts_event", None))

def record_to_candle(obj) -> Optional[Candle]:
    ts_ns = _parse_ts_ns(obj)
    if ts_ns is None: return None
    ts = dt.datetime.fromtimestamp(int(ts_ns) / 1e9, tz=UTC).astimezone(ET)
    o = _get_attr(obj, "open",  _get_attr(obj, "o", None))
    h = _get_attr(obj, "high",  _get_attr(obj, "h", None))
    l = _get_attr(obj, "low",   _get_attr(obj, "l", None))
    c = _get_attr(obj, "close", _get_attr(obj, "c", None))
    v = _get_attr(obj, "volume", _get_attr(obj, "v", 0)) or 0
    if None in (o, h, l, c): return None
    return Candle(ts, float(o)/PRICE_DIVISOR, float(h)/PRICE_DIVISOR,
                  float(l)/PRICE_DIVISOR, float(c)/PRICE_DIVISOR, int(v))

# --- Historical fetch ---
def fetch_ohlcv_1m(start_et: dt.datetime, end_et: dt.datetime) -> List[Candle]:
    client = Historical(DB_API_KEY)
    table = client.timeseries.get_range(
        dataset=DATASET, symbols=[SYMBOL], schema=SCHEMA,
        start=to_utc_str(start_et), end=to_utc_str(end_et)
    )
    out: List[Candle] = []
    for row in table:
        c = record_to_candle(row)
        if c: out.append(c)
    return out

def bounds_et(day: dt.date, hhmm_start: str, hhmm_end: str, allow_prevday_start=False) -> Tuple[dt.datetime, dt.datetime]:
    h1,m1 = map(int, hhmm_start.split(":"))
    h2,m2 = map(int, hhmm_end.split(":"))
    start = ET.localize(dt.datetime.combine(day, dt.time(h1,m1)))
    end   = ET.localize(dt.datetime.combine(day, dt.time(h2,m2)))
    # If session crosses midnight (e.g., 20:00 -> 00:00), treat start as previous day
    if allow_prevday_start and (h1 > h2 or hhmm_end == "00:00"):
        start = start - dt.timedelta(days=1)
    return start, end if end > start else end + dt.timedelta(days=1)

def regular_session_bounds_et(day: dt.date):
    return bounds_et(day, "09:30", "16:00")

def level_from_window(start_et: dt.datetime, end_et: dt.datetime) -> Tuple[float, float]:
    cs = fetch_ohlcv_1m_safe(start_et, end_et)
    if not cs: raise RuntimeError(f"No data for window {start_et}–{end_et}")
    return max(c.h for c in cs), min(c.l for c in cs)

def build_levels_for_today_simple() -> Dict[str, float]:
    today = now_et().date()

    # 1) 09:00–09:59 box (pre-10am)
    box_s, box_e = bounds_et(today, "09:00", "09:59")
    box_high = box_low = None  # box disabled: no fetch

    # 2) PDH/PDL from prior regular session (09:30–16:00 previous weekday)
    prior = today - dt.timedelta(days=1)
    while prior.weekday() >= 5: prior -= dt.timedelta(days=1)
    rs_s, rs_e = regular_session_bounds_et(prior)
    try:
        pdh, pdl = level_from_window(rs_s, rs_e)
    except Exception:
        pdh, pdl = box_high, box_low  # fallback

    levels = {

        "pdh": pdh, "pdl": pdl
    }

    # remove box keys (disabled)
    for _k in ("box_high","box_low"):
        if _k in levels: levels.pop(_k, None)
    # 3) Optional Asia/London levels
    if INCLUDE_ASIA_LONDON:
        asia_s, asia_e = bounds_et(today, ASIA_START, ASIA_END, allow_prevday_start=True)
        london_s, london_e = bounds_et(today, LONDON_START, LONDON_END)
        try:
            asia_high, asia_low = level_from_window(asia_s, asia_e)
            levels["asia_high"] = asia_high; levels["asia_low"] = asia_low
        except Exception:
            pass
        try:
            lon_high, lon_low = level_from_window(london_s, london_e)
            levels["london_high"] = lon_high; levels["london_low"] = lon_low
        except Exception:
            pass

    os.makedirs(os.path.join(BASE_DIR, "data"), exist_ok=True)
    with open(os.path.join(BASE_DIR, "data", "levels.json"), "w") as f:
        json.dump({"date": str(today), "levels": levels}, f, indent=2)
    return levels

def displacement_ok(a: float, b: float) -> bool:
    return abs(a - b) >= MIN_DISPLACEMENT_TICKS * TICK_SIZE

def detect_fvg_3bar(c1: Candle, c2: Candle, c3: Candle):
    # Bull: c3.low > c1.high  | Bear: c3.high < c1.low
    if c3.l > c1.h and displacement_ok(c3.c, c1.c):
        return ("bull", (c1.h + c3.l) / 2.0)
    if c3.h < c1.l and displacement_ok(c1.c, c3.c):
        return ("bear", (c3.h + c1.l) / 2.0)
    return (None, None)

def _swept_any(c3, levels, direction: str) -> bool:
    """Return True if the last bar swept any active liquidity pool for the given direction.
    - direction 'bull'  → look for sweeps *below* lows (asia_low, london_low, pdl, [box_low])
    - direction 'bear'  → look for sweeps *above* highs (asia_high, london_high, pdh, [box_high])
    """
    pools = active_pools(levels, direction)
    if direction == "bull":
        targets = [levels.get(name) for name in pools if levels.get(name) is not None]
        return any(c3.l <= t <= c3.h for t in targets)
    else:
        targets = [levels.get(name) for name in pools if levels.get(name) is not None]
        return any(c3.l <= t <= c3.h for t in targets)
def levels_cmd():
    """Build levels to data/levels.json and (optionally) alert Discord."""
    import datetime as dt
    today = now_et().date()
    levels = build_levels_for_today_simple()

    # write file used by live
    os.makedirs(os.path.join(BASE_DIR, "data"), exist_ok=True)
    out = {"date": today.isoformat(), "levels": levels}
    with open(os.path.join(BASE_DIR, "data", "levels.json"), "w") as f:
        json.dump(out, f, indent=2)

    # optional Discord summary
    if os.getenv("SEND_LEVELS_ALERT","false").lower() in ("1","true","yes","on"):
        lines = [f"**Levels {today}**"]
        for k in ("pdh","pdl","asia_high","asia_low","london_high","london_low"):
            v = levels.get(k)
            if v is not None:
                lines.append(f"`{k}`: {v:.2f}")
        _post_to_discord("\n".join(lines))

    print(json.dumps({"ok": True, "levels": levels}, indent=2))
def fetch_ohlcv_1m_safe(start, end):
    """Fetch OHLCV with small back-off if Databento says the window is too fresh."""
    import datetime as dt
    tries = 0
    while True:
        try:
            return fetch_ohlcv_1m(start, end)
        except Exception as e:
            msg = str(e)
            if ("data_end_after_available_end" in msg or "data_start_after_available_end" in msg) and tries < 4:
                end = end - dt.timedelta(minutes=2)
                tries += 1
                continue
            if "falls entirely inside a weekend" in msg:
                return []
            raise


# ------------------------------ BOX-FREE LEVELS BUILDER ------------------------------
def fetch_ohlcv_1m_safe(start, end):
    """Fetch OHLCV with small back-off if Databento says the window is too fresh."""
    import datetime as dt
    tries = 0
    while True:
        try:
            return fetch_ohlcv_1m(start, end)
        except Exception as e:
            msg = str(e)
            if ("data_end_after_available_end" in msg or "data_start_after_available_end" in msg) and tries < 4:
                end = end - dt.timedelta(minutes=2)
                tries += 1
                continue
            if "falls entirely inside a weekend" in msg:
                return []
            raise

def build_levels_for_today_simple():
    """Build PDH/PDL (calendar prior day) + Asia(prev day 20:00→00:00) + London(02:00→05:00), all half-open [start,end)."""
    import datetime as dt

    def hi_lo(start_dt, end_dt):
        # enforce half-open by trimming end one second back so it never includes the end-minute
        end_adj = end_dt - dt.timedelta(seconds=1)
        cs = fetch_ohlcv_1m_safe(start_dt, end_adj)
        if not cs:
            return None, None
        return float(max(c.h for c in cs)), float(min(c.l for c in cs))

    today = now_et().date()
    y = today - dt.timedelta(days=1)

    # PDH/PDL: previous calendar day 00:00 → 23:59 (treat as inclusive minute by using 23:59:59)
    pd_start = ET.localize(dt.datetime.combine(y, dt.time(0, 0)))
    pd_end   = ET.localize(dt.datetime.combine(y, dt.time(23, 59, 59)))
    pd_cs = fetch_ohlcv_1m_safe(pd_start, pd_end)
    pdh = float(max(c.h for c in pd_cs)) if pd_cs else None
    pdl = float(min(c.l for c in pd_cs)) if pd_cs else None

    # Asia: previous day 20:00 → today 00:00 (half-open)
    asia_start = ET.localize(dt.datetime.combine(y, dt.time(20, 0)))
    asia_end   = ET.localize(dt.datetime.combine(today, dt.time(0, 0)))
    asia_high, asia_low = hi_lo(asia_start, asia_end)

    # London: today 02:00 → 05:00 (half-open)
    london_start = ET.localize(dt.datetime.combine(today, dt.time(2, 0)))
    london_end   = ET.localize(dt.datetime.combine(today, dt.time(5, 0)))
    london_high, london_low = hi_lo(london_start, london_end)

    levels = {
        "pdh": pdh,
        "pdl": pdl,
        "asia_high": asia_high,
        "asia_low": asia_low,
        "london_high": london_high,
        "london_low": london_low,
    }
    return {k: v for k, v in levels.items() if v is not None}
def _pdh_window(today_et_date):
    import datetime as _dt
    mode = _os.getenv("PDH_MODE", "GLOBEX").strip().upper()
    if mode == "RTH":
        y = today_et_date - _dt.timedelta(days=1)
        start = ET.localize(_dt.datetime.combine(y, _dt.time(9,30)))
        end   = ET.localize(_dt.datetime.combine(y, _dt.time(16,0)))
        return start, end
    elif mode == "CALENDAR":
        y = today_et_date - _dt.timedelta(days=1)
        start = ET.localize(_dt.datetime.combine(y, _dt.time(0,0)))
        end   = ET.localize(_dt.datetime.combine(y, _dt.time(23,59)))
        return start, end
    # default GLOBEX previous session: 18:00 (D-1) → 17:00 (D0)
    y = today_et_date - _dt.timedelta(days=1)
    start = ET.localize(_dt.datetime.combine(y, _dt.time(18,0)))
    end   = ET.localize(_dt.datetime.combine(today_et_date, _dt.time(17,0)))
    return start, end

import os as _os, json as _json, urllib.request as _ur
def _post_to_discord(msg: str):
    wh = _os.getenv("DISCORD_WEBHOOK")
    if not wh: return
    data = _json.dumps({"content": msg}).encode()
    req = _ur.Request(wh, data=data, headers={"Content-Type":"application/json"})
    try: _ur.urlopen(req, timeout=5).read()
    except Exception: pass



if __name__ == "__main__":
    import argparse
    ap = argparse.ArgumentParser()
    ap.add_argument("--build-levels", action="store_true")
    ap.add_argument("--live", action="store_true")
    args = ap.parse_args()
    if args.build_levels:
        levels_cmd()
    elif args.live:
        live_cmd()
    else:
        print("Nothing to do. Use --build-levels or --live")
